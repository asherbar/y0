(ns example-lang)

;; # Example Language

;; In this module we define the semantics of an example language: $y_1$. The
;; language will syntactically resemble Clojure, but will be statically-typed.

;; Most of the semantics of the language will revolve around its type system.
;; In the following we will define it, step by step.

;; ## Expression Types

;; We begin with defining `typeof`, a predicate to associate types to
;; expressions. In a way, the predicate `typeof` _defines_ the sub-language
;; of expressions because everything that can be given a type _is a valid
;; expression_.

;; We first define the base-case for this predicate. It uses the [built-in
;; predicate `inspect`](builtins.md#inspect) to understand the _kind_ of
;; expression, and calls `typeof-inspected` to pattern-match on the kind.
(all [x t]
     (typeof x t) <-
     (exist [k]
            (inspect x k)
            (typeof-inspected k x t)))

;; Now we define the base cases for `typeof-inspected`, starting with the base
;; case, rejecting kinds that are not supported by a specific rule.
(all [k x t]
     (typeof-inspected k x t ! x "is not a y1 expression"))

;; Now things that are not explicitly defined as $y_1$ expressions (so, all
;; things at this point) will result in this error message.
(assert
 (exist [t] (typeof foo t) ! foo "is not a y1 expression"))

;; Next, we add cases for the different literal types.
(all [x]
     (typeof-inspected :int x int))
(all [x]
     (typeof-inspected :float x float))
(all [x]
     (typeof-inspected :string x string))

(assert
 (typeof 42 int)
 (typeof 3.141593 float)
 (typeof "foo bar" string))

;; Vectors are assumed to have the same type for all elements. The type of
;; the first element is inferred and all elements need to match.
(all [v t]
     (typeof-inspected :vector v (vector t)) <-
     (all-typesof v t))

;; It uses a new predicate, `all-typesof` to unify the types of all elements in
;; the vector to a single type `t`.
(all [x t]
     (all-typesof x t ! "all-typesof does not support value" x))
(all [x xs t]
     (all-typesof [x & xs] t) <-
     (exist [t']
            (typeof x t)
            (all-typesof xs t')
            (= t t' ! "type mismatch between elements in a vector." x "is" t "while" xs "are" t')))
(all [t]
     (all-typesof [] t))


(assert
 (typeof [1] (vector int))
 (typeof [1 2 3] (vector int))
 (exist [t]
        (typeof [1 2 "three"] t)
        ! "type mismatch between elements in a vector." 2 "is" int
        "while" ["three"] "are" string))

;; ## Built-in Operators

;; $y_0$ defines a few operators that can be used in expressions.

;; Arithmetic (binary) operators are defined for numeric types (`int` and
;; `float`), and require that the operands are of the same type. The returnede
;; type is the same as the operands.
(all [a b t]
     (typeof (+ a b) t) <-
     (typeof a t)
     (exist [t']
            (typeof b t')
            (= t t' ! "Type mismatch in +." a "has type" t "while" b "has type" t')
            (numeric-type t)))

;; This definition provides a match for the `typeof` predicate directly. It
;; requires that both operands are of the same type. Then it requires that the
;; common type is numeric, using the `numeric-type` predicate that is defined
; as follows:

(all [x]
     (numeric-type x ! x "is not a numeric type"))
(all [] (numeric-type int))
(all [] (numeric-type float))

(assert
 (typeof (+ 1 (+ 2 3)) int)
 (typeof (+ 1.1 (+ 2.2 3.3)) float)
 (exist [t]
        (typeof (+ 1 (+ 2.2 3.3)) t)
        ! "Type mismatch in +." 1 "has type" int "while" (+ 2.2 3.3) "has type" float)
 (exist [t]
        (typeof (+ "1" (+ "2" "3")) t)
        ! string "is not a numeric type"))

;; Since we have at least three more operators to define, let's automate the
;; process using the following [translation rule](statements.md):
(all [op]
     (defbinumop op) =>
     (all [a b t]
          (typeof (op a b) t) <-
          (typeof a t)
          (exist [t']
                 (typeof b t')
                 (= t t' ! "Type mismatch in" op ":" a "has type" t "while" b "has type" t')
                 (numeric-type t))))

;; This repeats the rule for `(+ a b)`, but applies it to any operator that
;; will be defined using `defbinumop`.

;; Now we can define the rest of the operators and check that they are defined.
(defbinumop -)
(defbinumop *)
(defbinumop /)
(defbinumop mod)

(assert
 (typeof (- 1 (* 2 3)) int)
 (typeof (/ 1.1 (mod 2.2 3.3)) float)
 (exist [t]
        (typeof (* 1 (/ 2.2 3.3)) t)
        ! "Type mismatch in" * ":" 1 "has type" int "while" (/ 2.2 3.3) "has type" float)
 (exist [t]
        (typeof (mod "1" (- "2" "3")) t)
        ! string "is not a numeric type"))
