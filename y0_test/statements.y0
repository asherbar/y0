(ns statements)

;; # Statements and Translation Rules

;; Statements are top-level s-expressions in a $y_0$ program. In the
;; [introduction](hello.md) we have encountered two types of statements:
;; A _rule_, using the keyword `all`, and a _test block_, using the
;; keyword `test`.

;; However, $y_0$ is extensible with regard to statements, allowing
;; modules to define new types of statements, by giving them meaning.

;; The way to give meaning to a statement is to define how it
;; _translates_ to other types of statements, and eventually to rules
;; and test blocks, which already have meaning in $y_0$.

;; ## Translation Rules

;; Translation rules define the meaning of statements by defining
;; how they translate to other statements.

;; A tranlation rule has the form:
;; `(all [vars...] head => statements...)`, where `vars...` are zero
;; or more symbols representing free variables, `head` is a pattern
;; of the statement type being defined, possibly containing symbols
;; from `vars...`. `statements...` represents zero or more
;; s-expressions that represent statements. These could be rules,
;; test blocks or other statements defined through their own 
;; translation rules.

;; ### An Example

;; To demonstrate this, we will walk through an example. The statement
;; `(defoo x)` for some value `x` means that `x` is foo. The statement
;; `(defbar x)` for some value `x` means that `x` is bar.

;; The predicates `foo` and `bar` succeed on things that are either
;; foo or bar respectively, and fail for all others.

;; We begin by defining the base cases for `is-foo` and `is-bar`:
(all [x]
     (foo x ! x "is not foo"))
(all [x]
     (bar x ! x "is not bar"))

;; Now, to give meaning to `defoo` and `defbar`, we define a translation
;; rule for each of them.
(all [x]
     (defoo x) => (all [] (foo x)))
(all [x]
     (defbar x) => (all [] (bar x)))

;; These rules translate each statement into a trivial rule that defines
;; the value provided in the statement as either foo or bar.

;; Now we can use the newly-created statements...
(defoo 1)
(defbar 2)

;; And expect to see their effect.
(test
 (foo 1)
 (bar 2)
 (foo 2 ! 2 "is not foo")
 (bar 1 ! 1 "is not bar"))
